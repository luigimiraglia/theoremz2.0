import { createClient, SupabaseClient } from '@supabase/supabase-js';

// SOLO Supabase PostgreSQL - database hostato affidabile
console.log(`[Analytics DB] Environment: ${process.env.NODE_ENV}`)      .select('page_url')
      .gte('created_at', startDate)
      .lte('created_at', endDate)
      .not('page_url', 'is', null);
    
    if (error) throw error;
    
    // Raggruppa per pagina
    const pageCounts: Record<string, number> = {};
    data?.forEach((row: any) => {
      pageCounts[row.page_url] = (pageCounts[row.page_url] || 0) + 1;
    });
    
    return Object.entries(pageCounts)
      .map(([page_url, visits]) => ({ page_url, visits }))[Analytics DB] Using ONLY Supabase PostgreSQL database`);

if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
  console.error(`[Analytics DB] ERRORE: Variabili Supabase mancanti!`);
  console.error(`[Analytics DB] SUPABASE_URL presente: ${!!process.env.NEXT_PUBLIC_SUPABASE_URL}`);
  console.error(`[Analytics DB] SERVICE_ROLE_KEY presente: ${!!process.env.SUPABASE_SERVICE_ROLE_KEY}`);
  throw new Error('Supabase database credentials not found');
}

console.log(`[Analytics DB] Supabase URL: ${process.env.NEXT_PUBLIC_SUPABASE_URL}`);

let supabase: SupabaseClient;

try {
  // Usa service role key per operazioni server-side
  supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
  console.log(`[Analytics DB] Supabase client created successfully`);
} catch (error) {
  console.error(`[Analytics DB] Failed to create Supabase client:`, error);
  throw error;
}

// Funzione per verificare lo schema del database
async function verifyDatabaseSchema(): Promise<void> {
  console.log('[Analytics DB] Verifying PostgreSQL database schema...')
  
  const tables = ['events', 'sessions', 'conversions', 'daily_stats']
  
  for (const table of tables) {
    try {
      const { data, error } = await supabase
        .from(table)
        .select('*')
        .limit(1)
      
      if (error) {
        console.log(`[Analytics DB] ${table} table: MISSING`)
      } else {
        console.log(`[Analytics DB] ${table} table: EXISTS`)
      }
    } catch (error) {
      console.log(`[Analytics DB] Error checking ${table} table:`, error)
    }
  }
  
  console.log('[Analytics DB] Database verification completed')
}

// Inizializza database
verifyDatabaseSchema();

// Funzioni di utilitÃ  per PostgreSQL
export const analyticsDB = {
  // Inserisci evento
  insertEvent: async (eventName: string, pagePath?: string, userId?: string, sessionId?: string, anonId?: string, params?: string, userAgent?: string, ipAddress?: string) => {
    const { data, error } = await supabase
      .from('events')
      .insert({
        event_name: eventName,
        page_url: pagePath,
        user_id: userId,
        session_id: sessionId,
        anon_id: anonId,
        params: params,
        user_agent: userAgent,
        ip_address: ipAddress
      });
    
    if (error) throw error;
    return data;
  },

  // Inserisci sessione
  insertSession: async (id: string, userId?: string, anonId?: string, landingPage?: string, referrer?: string, userAgent?: string, ipAddress?: string) => {
    const { data, error } = await supabase
      .from('sessions')
      .insert({
        id: id,
        user_id: userId,
        anon_id: anonId,
        landing_page: landingPage,
        referrer: referrer,
        user_agent: userAgent,
        ip_address: ipAddress
      });
    
    if (error) throw error;
    return data;
  },

  // Aggiorna sessione
  updateSession: async (id: string, pagesVisited: number, durationSeconds: number) => {
    const { data, error } = await supabase
      .from('sessions')
      .update({
        ended_at: new Date().toISOString(),
        pages_visited: pagesVisited,
        duration_seconds: durationSeconds
      })
      .eq('id', id);
    
    if (error) throw error;
    return data;
  },

  // Inserisci conversione
  insertConversion: async (conversionType: string, sessionId?: string, userId?: string, anonId?: string, conversionValue?: string, pagePath?: string) => {
    const { data, error } = await supabase
      .from('conversions')
      .insert({
        conversion_type: conversionType,
        session_id: sessionId,
        user_id: userId,
        anon_id: anonId,
        conversion_value: conversionValue,
        page_url: pagePath
      });
    
    if (error) throw error;
    return data;
  },

  // Update daily stats - versione semplificata per Supabase
  updateDailyStats: async (date: string, field: string, increment: number = 1) => {
    try {
      // Prima prova a fare update
      const { data: updateData, error: updateError } = await supabase
        .from('daily_stats')
        .update({ [field]: supabase.rpc('increment_field', { current_value: increment }) })
        .eq('date', date)
        .select();
      
      // Se non esiste, inserisci nuovo record
      if (!updateData || updateData.length === 0) {
        const { data: insertData, error: insertError } = await supabase
          .from('daily_stats')
          .insert({
            date: date,
            [field]: increment
          });
        
        if (insertError) {
          console.error(`[Analytics DB] Failed to insert daily stats:`, insertError);
          return null;
        }
        return insertData;
      }
      
      if (updateError) {
        console.error(`[Analytics DB] Failed to update daily stats:`, updateError);
        return null;
      }
      return updateData;
    } catch (error) {
      console.error(`[Analytics DB] Daily stats operation failed:`, error);
      return null;
    }
  },

  // Get conversion funnel
  getConversionFunnel: async (startDate: string, endDate: string) => {
    const { data, error } = await supabase
      .from('conversions')
      .select('conversion_type')
      .gte('timestamp', startDate)
      .lte('timestamp', endDate);
    
    if (error) throw error;
    
    // Raggruppa i risultati
    const funnel: any[] = [];
    const counts: Record<string, number> = {};
    
    data?.forEach((row: any) => {
      counts[row.conversion_type] = (counts[row.conversion_type] || 0) + 1;
    });
    
    Object.entries(counts).forEach(([type, count]) => {
      funnel.push({ conversion_type: type, count });
    });
    
    return funnel;
  },

  // Get top pages
  getTopPages: async (startDate: string, endDate: string, limit: number = 10) => {
    const { data, error } = await supabase
      .from('events')
      .select('page_path')
      .gte('created_at', startDate)
      .lte('created_at', endDate)
      .not('page_path', 'is', null);
    
    if (error) throw error;
    
    // Raggruppa e conta
    const pageCounts: Record<string, number> = {};
    data?.forEach((row: any) => {
      pageCounts[row.page_path] = (pageCounts[row.page_path] || 0) + 1;
    });
    
    return Object.entries(pageCounts)
      .map(([page_path, visits]) => ({ page_path, visits }))
      .sort((a, b) => b.visits - a.visits)
      .slice(0, limit);
  },

  // Get session stats
  getSessionStats: async (startDate: string, endDate: string) => {
    const { data, error } = await supabase
      .from('sessions')
      .select('anon_id, duration_seconds, pages_visited')
      .gte('started_at', startDate)
      .lte('started_at', endDate);
    
    if (error) throw error;
    
    const uniqueVisitors = new Set(data?.map((s: any) => s.anon_id)).size;
    const totalSessions = data?.length || 0;
    const avgDuration = data?.reduce((sum: number, s: any) => sum + (s.duration_seconds || 0), 0) / totalSessions || 0;
    const avgPages = data?.reduce((sum: number, s: any) => sum + (s.pages_visited || 0), 0) / totalSessions || 0;
    
    return [{
      total_sessions: totalSessions,
      unique_visitors: uniqueVisitors,
      avg_duration: avgDuration,
      avg_pages_per_session: avgPages
    }];
  },

  // Get daily stats range
  getDailyStatsRange: async (startDate: string, endDate: string) => {
    const { data, error } = await supabase
      .from('daily_stats')
      .select('*')
      .gte('date', startDate)
      .lte('date', endDate)
      .order('date', { ascending: false });
    
    if (error) throw error;
    return data || [];
  },

  // Get recent events
  getRecentEvents: async (limit: number = 100) => {
    const { data, error } = await supabase
      .from('events')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(limit);
    
    if (error) throw error;
    return data || [];
  },

  // Get funnel entries daily
  getFunnelEntriesDaily: async (startDate: string, endDate: string) => {
    const { data, error } = await supabase
      .from('daily_stats')
      .select('date, quiz_parent_clicks, quiz_student_clicks, popup_clicks')
      .gte('date', startDate)
      .lte('date', endDate)
      .order('date', { ascending: true });
    
    if (error) throw error;
    return data || [];
  },

  // Get total visits daily
  getTotalVisitsDaily: async (startDate: string, endDate: string) => {
    const { data, error } = await supabase
      .from('daily_stats')
      .select('date, total_pageviews')
      .gte('date', startDate)
      .lte('date', endDate)
      .order('date', { ascending: true });
    
    if (error) throw error;
    return data?.map((row: any) => ({ date: row.date, total_visits: row.total_pageviews })) || [];
  },

  // Get black page visits daily
  getBlackPageVisitsDaily: async (startDate: string, endDate: string) => {
    const { data, error } = await supabase
      .from('daily_stats')
      .select('date, black_page_visits')
      .gte('date', startDate)
      .lte('date', endDate)
      .order('date', { ascending: true });
    
    if (error) throw error;
    return data || [];
  },

  // Get buy clicks daily
  getBuyClicksDaily: async (startDate: string, endDate: string) => {
    const { data, error } = await supabase
      .from('events')
      .select('created_at')
      .eq('event_name', 'subscribe_click')
      .gte('created_at', startDate)
      .lte('created_at', endDate);
    
    if (error) throw error;
    
    // Raggruppa per data
    const dailyCounts: Record<string, number> = {};
    data?.forEach((row: any) => {
      const date = row.created_at.split('T')[0];
      dailyCounts[date] = (dailyCounts[date] || 0) + 1;
    });
    
    return Object.entries(dailyCounts)
      .map(([date, buy_clicks]) => ({ date, buy_clicks }))
      .sort((a, b) => a.date.localeCompare(b.date));
  },

  // Test connection
  testConnection: async () => {
    try {
      const { count, error } = await supabase
        .from('events')
        .select('*', { count: 'exact', head: true });
      
      if (error) {
        return { success: false, error: error.message };
      }
      
      return { success: true, message: 'Database connection successful', count };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  },

  // Debug info
  getTableInfo: async () => {
    try {
      // Test se possiamo accedere alle tabelle usando head request
      const { count: eventsCount, error: eventsError } = await supabase
        .from('events')
        .select('*', { count: 'exact', head: true });
        
      const { count: sessionsCount, error: sessionsError } = await supabase
        .from('sessions')
        .select('*', { count: 'exact', head: true });
      
      return {
        type: 'supabase_postgresql',
        tables: [
          { name: 'events', accessible: !eventsError, count: eventsCount },
          { name: 'sessions', accessible: !sessionsError, count: sessionsCount },
          { name: 'conversions', accessible: true },
          { name: 'daily_stats', accessible: true }
        ]
      };
    } catch (error) {
      return { 
        type: 'supabase_postgresql_error', 
        tables: [], 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }
};

export default analyticsDB;